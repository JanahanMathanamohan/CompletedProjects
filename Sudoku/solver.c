#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
// variable decleration
// holds the sudoku puzzle
int puzzle [9][9];
// array to hold all possible values for the empty value
int possible [81][9];
// array to hold the location of empty spaces
int spaces [81];
// method declearation
void clear();
void fill (int row, int col);
void checkfill (void);
int hash(int row, int col);
int dehashcol(int num);
int dehashrow(int num);
bool complete (int nextSpace);
void printing ();


void solve(int sudoku[][9])
{
	// clears all the arrays
	clear();
	// Opnens file and reads the inputs
	FILE *f = fopen("solutions.txt","w");
	for(int i = 0; i < 9; i++)
	{
		for(int j = 0; j < 9; j++)
		{
			puzzle[i][j] = sudoku[i][j];
		}
	}
	// Fills the empty locations with possible values
	checkfill();
	// Starts the recursice algorithm to solve the puzzle
	if(complete(0))
	{
		
		for(int i = 0; i < 9; i++)
		{
			for(int j = 0; j < 9; j++)
			{
				fprintf(f,"%d ",puzzle[i][j]);
			}
			fprintf(f,"\n");
		}
		fprintf(f,"\n");

	}
	fclose(f);
}
// Initializes the array to default value
void clear()
{
	// Sets the puzzle array to 0
	for(int i = 0; i < 9; i++)
	{
		for(int j = 0; j < 9; j++)
		{
			puzzle[i][j] = 0;
		}
	}
	// Sets the possible empty spaces to 0
	for(int i = 0; i < 81; i++)
	{
		for(int j = 0; j < 9; j++)
		{
			possible[i][j] = 0;

		}
	}
	// Sets the possible location to 100 cause it is not a possible location for an empty space
	for(int i = 0; i < 81; i++)
	{
		spaces[i] = 100;
	}
}

// Checks if the number passed through is a valid value
bool check (int row, int col, int num)
{
	// Sets up values to check for a box
	int rowstart = (row/3) * 3;
	int columnstart = (col/3) * 3;
	// loops to check the nine value in the row, col and box
	for(int j = 0; j < 9; j++)
	{	
		// Checks the col for a matching number
		if(puzzle[row][j] == num)
		{
			return false;
		}
		// Checks the row for a matching number
		if(puzzle[j][col] == num)
		{
			return false;
		}
		// checks the box for a matching number
		if(puzzle[rowstart+j%3][columnstart+j/3] == num)
		{
			return false;
		}
	}
	// returns true if there is no matching number
	return true;
}
// Puts all possible values for the empty spaces into possibilites and puts the location for empty spaces into location
void checkfill ()
{
	//set the counter to 0 for empty space
	int empty = 0;
	for(int row = 0; row < 9; row++)
	{
		for(int col = 0; col < 9; col++)
		{	
			if(puzzle [row][col] == 0)
			{	// Sets counter to 0 for the number of values that can go into that empty space
				int count = 0;
				//puts the location into spaces for the empty space
				spaces[empty] = hash(row,col);
				empty++;
				// Checks for the numbers that can go into possible for the empty space
				for(int num = 1; num < 10; num++)
				{	
					if(check(row, col, num))
					{	
						// If the number can go in we hash the row and col to get a locataion and the put the number into that location in the count position
						possible[hash(row,col)][count] = num;
						count++;
					}
				}
			}
		}
	}

}
// recursive function to solve the puzzle with the input being the index of the spaces array
bool complete (int nextSpace)
{	
	// Gets the hashed location of the next empty space and puts it into location
	int location = spaces[nextSpace];
	// Sets the counter for the next value to 0
	int nextValue = 0;
	// Checks for the end of the empty spaces array 
	if(location != 100)
	{
		// if it is not the end of the empty spaces it loops through all the possible values of the empty space loaction
		while(possible[location][nextValue] != 0)
		{	
			//Gets the row and col from the hashed location value
			int row = dehashrow(location);
			int col = dehashcol(location);
			// Checks if the poosible value is able to be put in
			if(check(row,col,possible[location][nextValue]))
			{
				//place the value into the puzzle in the space
				puzzle[row][col]= possible[location][nextValue];
				//recursively calls the method and moves to the next empty space
				if(complete(nextSpace+1))
				{
					// if the value works returns true
					return true;
				}else 
				{
					// if it cannot find a value into the inner recursion sets the space back to 0
					puzzle[row][col]=0;	
				}

			}
			// increments the counter to get the next value for that empty space
			nextValue++;
		}
		// if none of the values can go in it cannot be solved
		return false;	
	}else
	{
		//It reached the end of spaces so it returns true end of recursion.
		return true;
	}
	
	
}
// Hashing is donw so can link possible values to a location in the puzzle
//Makes the row and col become a unique number as a reference to a location from numbers 0 - 80
int hash (int row, int col)
{
	return ((row)*9 + col);
}
//Takes the location generated by the hasdj and returns the col it is located in
int dehashcol(int num)
{
	return num%9;
}
//Takes the location generated by the has and returns the row it is located in
int dehashrow(int num)
{
	return num/9;
}
